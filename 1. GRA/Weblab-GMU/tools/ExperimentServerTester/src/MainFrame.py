"""Subclass of MainFrameBase, which is generated by wxFormBuilder."""
from multiprocessing import synchronize
import string

import wx
import pickle
import re
import base64
import os
import threading

import mst_gui
from threaded import *
import traced

import LogViewer
import LogEntry
import LogManager
from ExperimentServerTester import IExperimentServerTesterNotifier
from results import *


# Implementing MainFrameBase
class MainFrame(mst_gui.MainFrameBase, IExperimentServerTesterNotifier):
    
    def __init__(self, parent, experiment_server_tester):
        mst_gui.MainFrameBase.__init__(self, parent)

        self.mMST = experiment_server_tester
        self.mMST.Notifier = self
        
        self.ResizeLog(self.mLogGrid.GetSize(), 0.5, 0.5)
        self.mStatusBar.SetStatusText("Test", 0)
        self.Status = "ExperimentServerTester"
        self.mControlsPersistence = {}
        self.mLogManager = LogManager.LogManager()
        self.LoadControlContents()
        
        self.ControlsEnable(True, False, True)
        
        EVT_RESULT(self, self.OnResult)
        
    def OnResult(self, event):
        """
        Called whenever a worker thread provides the main loop with a result.
        """
        event.data()
        
    def SetStatus(self, text):
        self.mStatusBar.SetStatusText(text, 0)
        
    def GetStatus(self):
        return self.mStatusBar.GetStatusText(0)
    
    Status = property(GetStatus, SetStatus)
    
    def SaveControlContents(self):
        # BUG: Currently wxFilePicker does not work on Linux, so we're using a text field and a button instead.
        
        host = self.mHostText.GetValue()
        port = self.mPortText.GetValue()
        uri = self.mUriText.GetValue()
        
        #script_file = self.mScriptFilePicker.GetTextCtrlValue()
        script_file = self.mScriptPickerPath.GetValue()
        
        #sendfile = self.mFilePicker.GetTextCtrlValue()
        sendfile = self.mScriptPickerPath.GetValue()
        
        self.mControlsPersistence["host"] = host
        self.mControlsPersistence["port"] = port
        self.mControlsPersistence["scriptfile"] = script_file
        self.mControlsPersistence["sendfile"] = sendfile
        self.mControlsPersistence["uri"] = uri
        pickle.dump(self.mControlsPersistence, file("persistence.dat", "w"))
        
    def LoadControlContents(self):
        try:
            dic = pickle.load(file("persistence.dat", "r"))
        except Exception, e:
            return
        try:
            if dic is not None:
                self.mControlsPersistence = dic
                self.mHostText.SetValue(self.mControlsPersistence["host"])
                self.mPortText.SetValue(self.mControlsPersistence["port"])
                self.mUriText.SetValue(self.mControlsPersistence["uri"])
                
                #self.mScriptFilePicker.SetPath(self.mControlsPersistence["scriptfile"])
                self.mScriptPickerPath.SetValue(self.mControlsPersistence["scriptfile"])
                
                #self.mFilePicker.SetPath(self.mControlsPersistence["sendfile"])
                self.mFilePickerPath.SetValue(self.mControlsPersistence["sendfile"])
                
        except Exception, e:
            wx.MessageBox("Possibly corrupt persistence.dat. Removing it. Error: %s" % str(e))
            os.remove("persistence.dat")
            
# Handlers for MainFrameBase events.
    
    def OnActivate(self, event):
        pass
#    
    def OnActivateApp(self, event):
        pass
    
    def OnPaint(self, event):
        mst_gui.MainFrameBase.OnPaint(self, event)

    def OnClose(self, event):
        self.SaveControlContents()
        mst_gui.MainFrameBase.OnClose(self, event)
        
#    
#    def OnIconize( self, event ):
#        # TODO: Implement OnIconize
#        pass
#    
    def OnIdle(self, event):
        pass
    
    def OnEnterWindow(self, event):
        pass
#    
#    def OnHostText( self, event ):
#        # TODO: Implement OnHostText
#        pass
#    
#    def OnHostTextEnter( self, event ):
#        # TODO: Implement OnHostTextEnter
#        pass
#    
    def OnPortText( self, event ):
        event.Skip()
#    
#    def OnPortTextEnter( self, event ):
#        # TODO: Implement OnPortTextEnter
#        pass
#    
    
    def OnConnect(self, event):
        self.SaveControlContents()
        
        host = self.mHostText.GetValue()
        if host == "":
            wx.MessageBox("Host may not be empty", "Error")
            return
        
        port = self.mPortText.GetValue()
        if port == "":
            wx.MessageBox("Port may not be empty", "Error")
            return
        
        uri = self.mUriText.GetValue()
        
        if(not self.mMST.is_connected()):
            self.ControlsEnable(False, False, False)
            self.mMST.connect_t(host, port, uri)
        else:
            self.mMST.disconnect()
            self.Status = "Disconnected from %s : %s" % (host, port)
        
    
    def Log(self, sent, recv):
        with self.mLogManager.mLock:
            entry = self.mLogManager.create_entry(sent, recv)
            self.mLogGrid.AppendRows(1, True)
            last_row = self.mLogGrid.GetNumberRows() - 1
            self.mLogGrid.SetCellValue(last_row, 0, entry.ShortSent)
            self.mLogGrid.SetCellValue(last_row, 1, entry.ShortReceived)
            self.mLogGrid.MakeCellVisible(last_row, 0)
        
        
    #    
    #    def OnFileChanged( self, event ):
    #        # TODO: Implement OnFileChanged
    #        pass
    #    
    #    def OnFileInfoText( self, event ):
    #        # TODO: Implement OnFileInfoText
    #        pass
    #    
    #    def OnFileInfoTextEnter( self, event ):
    #        # TODO: Implement OnFileInfoTextEnter
    #        pass
    #    
    #    def OnCommandText( self, event ):
    #        # TODO: Implement OnCommandText
    #        pass
    #    
    #    def OnCommandTextEnter( self, event ):
    #        # TODO: Implement OnCommandTextEnter
    #        pass


    def OnPortChar(self, event):
        event.Skip()
#        keycode = event.GetKeyCode()
#        if keycode < 255 and not chr(keycode).isalpha():
#            event.Skip()


    def OnStartExperiment(self, event):
        self.mMST.start_experiment_t()
    

    def OnSendFile(self, event):
        try:
            self.SaveControlContents()
           
            #path = self.mFilePicker.GetTextCtrlValue()
            path = self.mFilePickerPath.GetValue()
            
            if path == "":
                wx.MessageBox("A file must be chosen", "Error")
                return
            if not os.path.exists(path):
            	wx.MessageBox("The specified file does not seem to exist", "Error")
                return
            content = file(path, u"rb").read()
            info = self.mFileInfoText.GetValue()
            self.mMST.send_file_t(content, info)
        except Exception, e:
            wx.MessageBox("Could not send file", "Error")
            return

            
        #self.Log("{Send File}\n[File Info]\n\n%s\n\n[Content]\n\n: %s" % (info, content), result)
    
    def OnSendCommand(self, event):
        cmd = self.mCommandText.GetValue()
        self.mMST.send_command_t(cmd)
    
    def OnDispose(self, event):
        self.mMST.dispose_t()
    
#    def OnScriptFileChanged( self, event ):
#        # TODO: Implement OnScriptFileChanged
#        pass
#    
    def OnRunScript(self, event):
        try:
            self.SaveControlContents()
            
            script_file = self.mScriptPickerPath.GetValue()
            #script_file = self.mScriptFilePicker.GetTextCtrlValue()
            
            if(script_file == ""):
                wx.MessageBox("A script file must be chosen", "Error")
                return
            if(not os.path.exists(script_file)):
               wx.MessageBox("The specified script file does not seem to exist", "Error")
               return
            self.mMST.run_script_t(script_file)
        except Exception, e:
            wx.MessageBox("Error running script file: %s" % str(e), "Error")
#    
#    def OnLogCellChange( self, event ):
#        # TODO: Implement OnLogCellChange
#        pass
#    
    def OnLogCellLeftClick(self, event):
        with self.mLogManager.mLock:
            mst_gui.MainFrameBase.OnLogCellLeftClick(self, event)
        
            # We calculate the id of the entry behind the clicked column, knowing
            # that ids are assigned in an increasing order starting from 1
            next_id = self.mLogManager.get_next_id()
            id = event.GetRow() + 1
        
            entry = self.mLogManager.get_entry_by_id(id)
        
        dlg = LogViewer.LogViewer(self, entry) 
        dlg.ShowModal()
#    
#    def OnLogCellRightClick( self, event ):
#        # TODO: Implement OnLogCellRightClick
#        pass
#    
#    def OnLogSelectCell( self, event ):
#        # TODO: Implement OnLogSelectCell
#        pass
#    
#    def OnLogKillFocus( self, event ):
#        # TODO: Implement OnLogKillFocus
#        pass
#    
#    def OnLogPaint( self, event ):
#        # TODO: Implement OnLogPaint
#        pass
#    
#    def OnLogSetFocus( self, event ):
#        # TODO: Implement OnLogSetFocus
#        pass
#    
    def OnLogSize(self, event):
        self.ResizeLog(event.GetSize(), 0.5, 0.5)
    
    def ResizeLog(self, size, sent_percent, recv_percent):    
        grid = self.mLogGrid
        grid.SetRowLabelSize(50);
        total_width = size.GetWidth() - grid.GetScrollThumb(wx.VERTICAL)
        width_cells = total_width - 50 - 0
        sent_width = width_cells * sent_percent
        recv_width = width_cells * recv_percent  
        grid.SetColSize(0, sent_width)
        grid.SetColSize(1, recv_width)
#    
#    def OnLogUpdateUI( self, event ):
#        # TODO: Implement OnLogUpdateUI
#        pass
#    
    def OnCleanLog(self, event):
        with self.mLogManager.mLock:
            cols = self.mLogGrid.GetNumberRows()
            if cols != 0:
                self.mLogGrid.DeleteRows(0, cols, True)
            self.mLogManager.clear()
        
    
    def ControlsEnable(self, connection = True, commands = False, connect_button = True):    
        
        # TODO: Consider replacing it back once the wxFilePicker works on Linux.
        #self.mFilePicker.Enable(commands)
        self.mFilePickerButton.Enable(commands)
        self.mFilePickerPath.Enable(commands);
        
        self.mFileInfoText.Enable(commands)
        self.mStartExperimentButton.Enable(commands)
        self.mCommandText.Enable(commands)
        self.mSendFileButton.Enable(commands)
        self.mDisposeButton.Enable(commands)
        self.mSendCommand.Enable(commands)
        self.mHostText.Enable(connection)
        self.mPortText.Enable(connection)    
        self.mConnectButton.Enable(connect_button)
        self.mUriText.Enable(connection)
    
        
    #  IExperimentServerTesterNotifier overrides
    def ConnectNotification(self, addr, port, result):
        if result:
            self.Log("{Connect to %s:%s}" % (addr, port), "{established}")
            self.mConnectButton.SetLabel("Disconnect")
            self.ControlsEnable(False, True, True)
            self.Status = "Connected to %s : %s" % (addr, port)
            self.ControlsEnable(False, True, True)
        else:
            self.ControlsEnable(True, False, True)
            self.Log("{Connect to %s:%s}" % (addr, port), "{FAILED}")  
            wx.MessageBox("Could not establish connection", "Error")  
            
    def StartExperimentNotification(self, result):
        self.Status = "Start Experiment sent. (Response: %s)" % result
        self.Log("{Start Experiment}", result)
    
    def SendCommandNotification(self, cmd, result):
        self.Log("{Command} %s" % cmd, result)
        self.Status = "Command sent. (Response: %s)" % result
       
    def SendFileNotification(self, file_content, file_info, result):
        try:
            decoded = base64.b64decode(file_content)
        except Exception, e:
            decoded = "Could not decode"
       
        decoded = filter(lambda x: x in string.printable, decoded)
        file_content = filter(lambda x: x in string.printable, file_content)
       
        print "Decoded: ", decoded
        try: 
            self.Log("{Send File}\n[File Info]\n\n%s\n\n[Decoded Content]:\n\n%s\n\n[Encoded Content]:\n\n%s" % 
                     (file_info, decoded, file_content), result)
            self.Status = "File sent. Response: %s" % result
        except Exception, e:
            self.Status = "Error on File Notification"
    
    def DisposeNotification(self, result):
        self.Log("{Dispose}", result)
        self.Status = "Dispose sent. (Response: %s)" % result
    
    def DisconnectNotification(self):
        self.Log("{Disconnected}", "")
        self.ControlsEnable(True, False, True)
        self.mConnectButton.SetLabel("Connect")
        
    
    def OnFilePickerButtonClicked( self, event ):
        filename = wx.FileSelector( u"Choose the file" )
        if len(filename) > 0:
            self.mFilePickerPath.SetValue(filename)
            
        
    def OnScriptPickerButtonClicked( self, event ):
        filename = wx.FileSelector(u"Choose the script file", "", "", ".py", "*.py")
        if len(filename) > 0:
            self.mScriptPickerPath.SetValue(filename)
    
    
